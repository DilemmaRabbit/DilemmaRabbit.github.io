<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcodes on Dilemma Rabbit</title>
    <link>https://DilemmaRabbit.github.io/leetcode/</link>
    <description>Recent content in Leetcodes on Dilemma Rabbit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Jan 2022 16:26:29 +0800</lastBuildDate><atom:link href="https://DilemmaRabbit.github.io/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode1010</title>
      <link>https://DilemmaRabbit.github.io/leetcode/leetcode1010/</link>
      <pubDate>Mon, 03 Jan 2022 16:26:29 +0800</pubDate>
      
      <guid>https://DilemmaRabbit.github.io/leetcode/leetcode1010/</guid>
      <description>å•é¡Œæè¿° åˆ†é¡ï¼šğŸŸ  medium ğŸŸ  ç›¸é—œä¸»é¡Œï¼šCounting, Hash_table, Array  é¡Œç›®ï¼ˆè‹±æ–‡ï¼‰ You are given a list of songs where the ith song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i &amp;lt; j with (time[i] + time[j]) % 60 == 0.  æ¸¬è³‡ Example 1: Input: time = [30,20,150,100,40] Output: 3 Explanation: Three pairs have a total duration divisible by 60: (time[0] = 30, time[2] = 150): total duration 180 (time[1] = 20, time[3] = 100): total duration 120 (time[1] = 20, time[4] = 40): total duration 60 Example 2: Input: time = [60,60,60] Output: 3 Explanation: All three pairs have a total duration of 120, which is divisible by 60.</description>
    </item>
    
    <item>
      <title>Leetcode 997</title>
      <link>https://DilemmaRabbit.github.io/leetcode/leetcode997/</link>
      <pubDate>Mon, 03 Jan 2022 13:14:32 +0800</pubDate>
      
      <guid>https://DilemmaRabbit.github.io/leetcode/leetcode997/</guid>
      <description>å•é¡Œæè¿° åˆ†é¡ï¼šğŸŸ¢ easy ğŸŸ¢ ç›¸é—œä¸»é¡Œï¼šGraph, Hash_table, Array é¡Œç›®ï¼ˆè‹±æ–‡ï¼‰ In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: 1. The town judge trusts nobody. 2. Everybody (except for the town judge) trusts the town judge. 3. There is exactly one person that satisfies properties 1 and 2. You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi.</description>
    </item>
    
  </channel>
</rss>
